---
title: "백준 3045번 변형시키기-대표적인 연결 리스트 문제"
categories: [data-structure]
---
*백준 알고리즘 3045번 문제는 정답률이 약 30%인 문제고 연결 리스트를 다루고 있으나, 굳이 이 문제를 곧이곧대로 풀어야 할 의무를 느끼지 못했다.*


'창영이'와 '상근이'의 개발자 지망생다운 우정을 엿볼 수 있어서 흥미로운 문제였다. 본문은 사진과 같다.


![이미지](https://user-images.githubusercontent.com/50163676/88260973-64058980-cd00-11ea-9839-dd42b415c751.png "문제-상")


![이미지](https://user-images.githubusercontent.com/50163676/88260979-65cf4d00-cd00-11ea-802e-2e5f227ff408.png "문제-하")


여기서 나는 문제를 살짝 뒤틀어, 상근이의 함수를 ‘ABC’로 만들었다.


 — 함수 A: 노드 X를 노드 Y의 __뒤로__ 이동시킨다.
 
 
 — 함수 B: 노드 X를 노드 Y의 __앞으로__ 이동시킨다.
 
 
 — 함수 C: 노드 X와 노드 Y의 __위치를 서로 바꾼다.(추가!)__ <BR/>
 
![이미지](https://user-images.githubusercontent.com/50163676/88363463-1863e600-cdbb-11ea-854a-dc830de3086c.jpeg "ABC함수 그림 해설") <BR/>
C 함수에서 주의해야 할 것은 노드 안의 데이터만 옮기지 말고 노드 자체를 옮겨야 한다는 것이다. 여기까지만 읽고 도전하는 것을 추천한다.<BR/>.<BR/>.<BR/>.<BR/>

도전해 보았는가? 사람에 따라서 매우 쉬웠을 수도 있고, 어렵게 느낄 수도 있다. 우선 우리 학교 학생들은 C 함수를 구현하는 데 어려움을 느꼈다. 그도 그럴 것이 데이터만 복사하는 것이 아니라 아예 사슬을 끊어내고 다시 잇는 작업이기 때문이다. 하지만 그림을 그리며 코딩에 임하면 어렵지 않게 해결할 수 있다.


함수들을 오목조목 뜯어보기 전에 우선 연결 리스트의 구조를 코드로 나타낼 줄 알아야 한다. 모두가 알다시피 연결 리스트는 __노드(Node)__ 들이 앞에서부터 주루룩 연결되어 마치 사슬과 같은 구조를 띠고 있으며, 처음을 가리키는 __head node(헤드 노드, 경우에 따라 헤드 포인터도 될 수 있다)__ 가 존재해야 한다. 또한 어느 하나의 노드를 잘못 가리켜 오류가 나는 것에 주의해야 한다. 마치 인파 속에서 상대방의 손을 놓치면 당분간 그 사람을 찾지 못하는 것과 비슷하다. 


여기서 컴퓨터의 잔혹함이 드러나는데, 한 번 사라지면 아예 노드 속 데이터에 접근하지 못한다는 사실이 그것이다. 이는 노드를 이루고 있는 __데이터 필드__ 와 __링크 필드__ 중 링크 필드의 관리에 서투르면 발생하며, 연결 리스트를 어렵게 느끼도록 하는 데 일조한다. 나 또한 C 함수를 해결하는 데 한 시간 정도가 걸렸던 것으로 기억한다.


덜 어렵게 느낄 수 있도록 연결 리스트를 구현하기 위한 클래스를 살펴보자. 먼저 각 노드를 구성하는 클래스다.


```cpp
class Node {
    int data;    // 정수형 데이터를 저장하는 데이터 필드
    Node* prev;  // 이전 노드를 가리키는 링크 필드
    Node* next;  // 다음 노드를 가리키는 링크 필드
    
public:
    
    Node (int val = 0) : data(val), prev(nullptr), next(nullptr) { } // 생성자
    
    Node* getPrev() { return prev; }
    Node* getNext() { return next; }
    int getData() { return data; }
    
    void setPrev(Node* prev) { this -> prev = prev; }
    void setNext(Node* next) { this -> next = next; }
    
    bool hasData(int val) { return data == val; }
    
    void display() { cout << data << " "; }
    
    void insertNext(Node* node) {
        if (node != nullptr) {
            node -> prev = this;
            node -> next = next;
            if (next != nullptr) next -> prev = node;
            next = node;
        }
    }
    
    void insertPrev(Node* node) {
        if (node != nullptr) {
            prev -> next = node; // 내 전의 다음은 들어오려는 녀석.
            node -> next = this; // 들어오려는 녀석의 다음은 나.
            node -> prev = prev; // 들어오려는 녀석의 전은 내 전.
            prev = node;         // 내 전은 들어오려는 녀석.
        }
    }
    
    Node* deleteNode() {
        if (prev != nullptr) prev -> next = next;
        if (next != nullptr) next -> prev = prev;
        return this;
    }
    
};

```
<BR/>
복잡한 프로그래밍, 특히 OOP의 장점인 클래스를 관리할 때 필수인 것은 주석을 다는 행위다. 주석을 달면 머리가 터질 것 같다가도 스스로에게 설명을 할 수 있어 이해의 속도가 조금 빨라진다. 마치 컴퓨터와 나와의 토론 같다고 표현해야 할까?<BR/>
노드 클래스의 멤버 변수는 세 개다. 이 문제에서는 정수형 데이터만 저장하기에, int로 선언해도 충분한 __데이터 필드__, 자신 이전의 노드를 가리키는 __링크 필드 하나__, 다음 노드를 가리키는 __링크 필드 둘__. 이들을 다른 프로그램에서 접근하고 변경하는 것을 막기 위해 캡슐화(encapsuliation)를 시키니 멤버 함수에 getPrev(), getNext(), getData()가 꼭 필요하다. 또한 후에 요구되는 복잡한 연산들을 위해 짜 준 다양한 멤버 함수들을 주목하시라. 직관적인 이름 덕분에 이해하는 데 그다지 어렵지 않을 것이다.<BR/><BR/>
노드 클래스에서 눈치챘듯이, 이 문제는 __이중 연결 리스트(Doubly linked list)__ 로 해결해야 한다. 이중 연결 리스트는 흔히 접하는 __단일 연결 리스트보다 데이터 관리가 용이하다는 장점이 있다.__ 단점은 역시나, 노드 간 링크를 관리하기 까다롭다는 것. 슬프지만 익숙해져야 리스트형 자료구조를 수월하게 다룰 수 있다.<BR/>
아래의 그림은 단일 연결 리스트와 이중 연결 리스트의 차이를 다룬 그림이다.<BR/><BR/>


다음은 본격적으로 연결 리스트를 다루기 위한 이중 연결 리스트 클래스다.<BR/>
```cpp
class DoubleLinkedList {
    Node head; // head가 가리키는 것이 첫 번째 데이터다.
public:
    DoubleLinkedList() : head(0) { } // 생성자
    ~DoubleLinkedList() { } // 소멸자
    
    //void clear() { while(!isEmpty()) delete remove(0); }
    Node* getHead() { return head.getNext(); } // 중요.
    bool isEmpty() { return getHead() == nullptr; }
    
    Node* getEntry(int pos) {
        Node* n = &head;
        for (int i = -1; i < pos; i++, n = n -> getNext())
            if (n == nullptr) break;
        return n;
    }
    void setting(int pos, Node* n) {
        Node* prev = getEntry(pos - 1); // n-1번째 노드를 찾아서
        if (prev != nullptr)
            prev -> insertNext(n); // n-1번째 노드 다음에 n 추가
    }
    
    void insert(int d, Node* n) { // A 함수를 위한 멤버 함수
        Node* f = find(d); // 데이터가 d인 노드를 찾아서
        if (f != nullptr) f -> insertNext(n); // 그 노드 다음에 n을 추가한다.
    }
    void preInsert(int d, Node* n) { // B 함수를 위한 멤버 함수
        Node* f = find(d); // 데이터가 d인 노드를 찾아서
        if (f != nullptr) f -> insertPrev(n); // 그 노드 이전에 n을 추가한다.
    }
    
    Node* remove(int d) {
        Node* n = find(d);    // data가 d인 노드를 찾아서
        return n -> deleteNode();       // 제거.
    }
    
    Node* find(int val) {   // 데이터가 val인 노드를 찾아서 반환한다.
        Node* found = NULL;
        for (Node* p = getHead(); p != NULL; p = p -> getNext()) {
            if (p -> hasData(val)) found = p;
        }
        return found;
    }
    
    void replace(int d, Node* n) {
        Node* f = find(d); // 데이터가 d인 노드를 찾는다.
        if (f != nullptr) {
            f -> insertNext(n);
            f -> deleteNode();
        }
    }
    
    void display() {
        for (Node* p = getHead(); p != NULL; p = p -> getNext())
            p -> display();
        cout << endl;
    }
    
    void swapNode(Node* a, Node* b) {  // !!!C 함수를 위한 멤버 함수!!!
        if (a -> getPrev() == NULL) head.setNext(b); // a가 첫 번째 노드일 때는? 예외사항.
        else
            a -> getPrev() -> setNext(b); // a의 prev의 next는 b가 되도록.
        
        if (b -> getPrev() == NULL) head.setNext(a); // b가 첫 번째 노드일 때는? 예외사항.
        else
            b -> getPrev() -> setNext(a); // b의 prev의 next는 a가 되도록.
        
        if (a -> getNext() == NULL) NULL; // a가 맨 마지막 노드일 때는? 예외사항.
        else
            a -> getNext() -> setPrev(b); // a의 next의 prev는 b가 되도록.
        
        if (b -> getNext() == NULL) NULL; // b가 맨 마지막 노드일 때는? 예외사항.
        else
            b -> getNext() -> setPrev(a); // b의 next의 prev는 a가 되도록.
        //----------------------------
        b -> setPrev(a -> getPrev()); // a의 prev가 b의 prev가 되도록.
        a -> setPrev(a -> getNext()); // a의 prev가 a의 next가 되도록.
        a -> setNext(b -> getNext()); // a의 next가 b의 next가 되도록.
        b -> setNext(a -> getPrev()); // b의 next가 a의 prev가 되도록.
    }
};
```


매우 복잡하다고 생각할지 모르나 역시 직관적이기에 이해하는 데 큰 어려움은 없을 것이다. __문제는 C 함수의 구현을 위한 swapNode(Node* a, Node* b) 멤버 함수다.__ 이 함수는 총 8단계의 알고리즘으로 이루어져 있으며 이해하기 위해서는 무조건 그림이 있어야 한다. 그림 없이는 관자놀이가 지끈거리는 현상을 피할 수 없다.<BR/>
문제를 풀이하며 연습장에 그렸던 그림과 함께 깔끔한 일러스트레이션 또한 함께 첨부하며 차근차근 설명하겠다.<BR/>
![이미지](https://user-images.githubusercontent.com/50163676/88270217-3fb1a900-cd10-11ea-9c2e-f97f14fea321.jpg "C 함수 해답")<BR/>
