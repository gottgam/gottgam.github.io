---
title: "백준 3045번 변형시키기-대표적인 연결 리스트 문제(1)"
categories: [data-structure]
---
*백준 알고리즘 3045번 문제는 정답률이 약 30%인 문제고 연결 리스트를 다루고 있으나, 굳이 이 문제를 곧이곧대로 풀어야 할 의무를 느끼지 못했다.*


'창영이'와 '상근이'의 개발자 지망생다운 우정을 엿볼 수 있어서 흥미로운 문제였다. 본문은 사진과 같다.


![이미지](https://user-images.githubusercontent.com/50163676/88260973-64058980-cd00-11ea-9839-dd42b415c751.png "문제-상")


![이미지](https://user-images.githubusercontent.com/50163676/88260979-65cf4d00-cd00-11ea-802e-2e5f227ff408.png "문제-하")


여기서 나는 문제를 살짝 뒤틀어, 상근이의 함수를 ‘ABC’로 만들었다.


 — 함수 A: 노드 X를 노드 Y의 __뒤로__ 이동시킨다.
 
 
 — 함수 B: 노드 X를 노드 Y의 __앞으로__ 이동시킨다.
 
 
 — 함수 C: 노드 X와 노드 Y의 __위치를 서로 바꾼다.(추가!)__
 
 
C 함수에서 주의해야 할 것은 노드 안의 데이터만 옮기지 말고 노드 자체를 옮겨야 한다는 것이다. 여기까지만 읽고 도전하는 것을 추천한다.



도전해 보았는가? 사람에 따라서 매우 쉬웠을 수도 있고, 어렵게 느낄 수도 있다. 우선 우리 학교 학생들은 C 함수를 구현하는 데 어려움을 느꼈다. 그도 그럴 것이 데이터만 복사하는 것이 아니라 아예 사슬을 끊어내고 다시 잇는 작업이기 때문이다. 하지만 그림을 그리며 코딩에 임하면 어렵지 않게 해결할 수 있다.


함수들을 오목조목 뜯어보기 전에 우선 연결 리스트의 구조를 코드로 나타낼 줄 알아야 한다. 모두가 알다시피 연결 리스트는 __노드(Node)__ 들이 앞에서부터 주루룩 연결되어 마치 사슬과 같은 구조를 띠고 있으며, 처음을 가리키는 __head node(헤드 노드, 경우에 따라 헤드 포인터도 될 수 있다)__ 가 존재해야 한다. 또한 어느 하나의 노드를 잘못 가리켜 오류가 나는 것에 주의해야 한다. 마치 인파 속에서 상대방의 손을 놓치면 당분간 그 사람을 찾지 못하는 것과 비슷하다. 


여기서 컴퓨터의 잔혹함이 드러나는데, 한 번 사라지면 아예 노드 속 데이터에 접근하지 못한다는 사실이 그것이다. 이는 노드를 이루고 있는 __데이터 필드__ 와 __링크 필드__ 중 링크 필드의 관리에 서투르면 발생하며, 연결 리스트를 어렵게 느끼도록 하는 데 일조한다. 나 또한 C 함수를 해결하는 데 한 시간 정도가 걸렸던 것으로 기억한다.


덜 어렵게 느낄 수 있도록 연결 리스트를 구현하기 위한 클래스를 살펴보자. 먼저 각 노드를 구성하는 클래스다.


```cpp
class Node {
    int data;    // 정수형 데이터를 저장하는 데이터 필드
    Node* prev;  // 이전 노드를 가리키는 링크 필드
    Node* next;  // 다음 노드를 가리키는 링크 필드
    
public:
    
    Node (int val = 0) : data(val), prev(nullptr), next(nullptr) { } // 생성자
    
    Node* getPrev() { return prev; }
    Node* getNext() { return next; }
    int getData() { return data; }
    
    void setPrev(Node* prev) { this -> prev = prev; }
    void setNext(Node* next) { this -> next = next; }
    
    bool hasData(int val) { return data == val; }
    
    void display() { cout << data << " "; }
    
    void insertNext(Node* node) {
        if (node != nullptr) {
            node -> prev = this;
            node -> next = next;
            if (next != nullptr) next -> prev = node;
            next = node;
        }
    }
    
    void insertPrev(Node* node) {
        if (node != nullptr) {
            prev -> next = node; // 내 전의 다음은 들어오려는 녀석.
            node -> next = this; // 들어오려는 녀석의 다음은 나.
            node -> prev = prev; // 들어오려는 녀석의 전은 내 전.
            prev = node;         // 내 전은 들어오려는 녀석.
        }
    }
    
    Node* deleteNode() {
        if (prev != nullptr) prev -> next = next;
        if (next != nullptr) next -> prev = prev;
        return this;
    }
    
};

```
<BR/>
복잡한 프로그래밍, 특히 OOP의 장점인 클래스를 관리할 때 필수인 것은 주석을 다는 행위다. 주석을 달면 머리가 터질 것 같다가도 스스로에게 설명을 할 수 있어 이해의 속도가 조금 빨라진다. 마치 컴퓨터와 나와의 토론 같다고 표현해야 할까?<BR/>
노드 클래스의 멤버 변수는 세 개다. 이 문제에서는 정수형 데이터만 저장하기에, int로 선언해도 충분한 __데이터 필드__, 자신 이전의 노드를 가리키는 __링크 필드 하나__, 다음 노드를 가리키는 __링크 필드 둘__. 이들을 다른 프로그램에서 접근하고 변경하는 것을 막기 위해 캡슐화(encapsuliation)를 시키니 멤버 함수에 getPrev(), getNext(), getData()가 꼭 필요하다. 또한 후에 요구되는 복잡한 연산들을 위해 짜 준 다양한 멤버 함수들을 주목하시라. 직관적인 이름 덕분에 이해하는 데 그다지 어렵지 않을 것이다.<BR/><BR/>

노드 클래스에서 눈치챘듯이, 이 문제는 __이중 연결 리스트(Doubly linked list)__ 로 해결해야 한다. 



